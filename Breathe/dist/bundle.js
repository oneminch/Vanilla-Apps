/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@keyframes/core/dist/keyframes.js":
/*!********************************************************!*\
  !*** ./node_modules/@keyframes/core/dist/keyframes.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __assign = this && this.__assign || function() {\n    return (__assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);\n        return t;\n    }).apply(this, arguments);\n}, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    return new (P = P || Promise)(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            var value;\n            result.done ? resolve(result.value) : ((value = result.value) instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n            })).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}, __generator = this && this.__generator || function(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (1 & t[0]) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        throw: verb(1),\n        return: verb(2)\n    }, \"function\" == typeof Symbol && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return function(op) {\n                if (f) throw new TypeError(\"Generator is already executing.\");\n                for (;_; ) try {\n                    if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), \n                    0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                    switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {\n                      case 0:\n                      case 1:\n                        t = op;\n                        break;\n\n                      case 4:\n                        return _.label++, {\n                            value: op[1],\n                            done: !1\n                        };\n\n                      case 5:\n                        _.label++, y = op[1], op = [ 0 ];\n                        continue;\n\n                      case 7:\n                        op = _.ops.pop(), _.trys.pop();\n                        continue;\n\n                      default:\n                        if (!(t = 0 < (t = _.trys).length && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {\n                            _ = 0;\n                            continue;\n                        }\n                        if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {\n                            _.label = op[1];\n                            break;\n                        }\n                        if (6 === op[0] && _.label < t[1]) {\n                            _.label = t[1], t = op;\n                            break;\n                        }\n                        if (t && _.label < t[2]) {\n                            _.label = t[2], _.ops.push(op);\n                            break;\n                        }\n                        t[2] && _.ops.pop(), _.trys.pop();\n                        continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [ 6, e ], y = 0;\n                } finally {\n                    f = t = 0;\n                }\n                if (5 & op[0]) throw op[1];\n                return {\n                    value: op[0] ? op[1] : void 0,\n                    done: !0\n                };\n            }([ n, v ]);\n        };\n    }\n}, __read = this && this.__read || function(o, n) {\n    var m = \"function\" == typeof Symbol && o[Symbol.iterator];\n    if (!m) return o;\n    var r, e, i = m.call(o), ar = [];\n    try {\n        for (;(void 0 === n || 0 < n--) && !(r = i.next()).done; ) ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally {\n        try {\n            r && !r.done && (m = i.return) && m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}, __spread = this && this.__spread || function() {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\n\nfunction __export(m) {\n    for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);\n}\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nvar keyframesSheet, add_px_to_style_1 = __importDefault(__webpack_require__(/*! add-px-to-style */ \"./node_modules/add-px-to-style/index.js\")), hyphenate_style_name_1 = __importDefault(__webpack_require__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\")), wait = function() {\n    return new Promise(function(accept) {\n        requestAnimationFrame(function() {\n            accept();\n        });\n    });\n};\n\nif (exports.isBrowser = \"undefined\" != typeof window, exports.isBrowser) {\n    var styleElem = document.createElement(\"style\");\n    styleElem.setAttribute(\"id\", \"keyframesjs-stylesheet\"), document.head.appendChild(styleElem), \n    keyframesSheet = styleElem.sheet;\n}\n\nvar clone = function(input) {\n    return Array.isArray(input) ? __spread(input) : \"object\" == typeof input ? __assign({}, input) : input.toString();\n}, voidFunction = function() {}, defaultCallbacks = {\n    onStart: voidFunction,\n    onBeforeStart: voidFunction,\n    onIteration: voidFunction,\n    onEnd: voidFunction,\n    onQueueComplete: voidFunction,\n    onCancel: voidFunction\n}, objToCss = function(obj) {\n    if (!Object.keys(obj).length) return \"\";\n    var result = \"\";\n    for (var key in obj) result += hyphenate_style_name_1.default(key) + \":\" + add_px_to_style_1.default(key, obj[key]) + \";\";\n    return result;\n}, Keyframes = function() {\n    function Keyframes(elem, debug) {\n        void 0 === debug && (debug = !1), this.playing = !1, this.previousCancel = voidFunction, \n        this.debug = !1, this.queueStore = [], this.callbacks = defaultCallbacks, this.animationstartListener = voidFunction, \n        this.animationendListener = voidFunction, this.animationiterationListener = voidFunction, \n        this.animationcancelListener = voidFunction, this.mountedElement = elem, this.frozenStyles = [], \n        this.debug = debug;\n    }\n    return Keyframes.isSupported = function() {\n        return void 0 !== document.body.style.animationName;\n    }, Keyframes.prototype.freeze = function() {\n        var _this = this, ruleCache = Keyframes.ruleCache[this.mountedElement.style.animationName];\n        if (ruleCache) {\n            var computedStyle_1 = __assign({}, getComputedStyle(this.mountedElement));\n            ruleCache.forEach(function(rule) {\n                _this.mountedElement.style[rule] = computedStyle_1[rule];\n            }), this.frozenStyles = __spread(new Set(this.frozenStyles.concat(ruleCache)));\n        }\n    }, Keyframes.prototype.unfreeze = function() {\n        var _this = this;\n        this.frozenStyles.length && (this.frozenStyles.forEach(function(rule) {\n            _this.mountedElement.style[rule] = \"\";\n        }), this.frozenStyles = []);\n    }, Keyframes.prototype.reset = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                  case 0:\n                    return this.log(\"reset\"), this.playing = !1, this.removeEvents(), this.mountedElement.style.animationPlayState = \"running\", \n                    this.mountedElement.style.animation = \"none\", [ 4, wait() ];\n\n                  case 1:\n                    return _a.sent(), [ 2, this ];\n                }\n            });\n        });\n    }, Keyframes.prototype.pause = function() {\n        return this.mountedElement.style.animationPlayState = \"paused\", this;\n    }, Keyframes.prototype.resume = function() {\n        return this.mountedElement.style.animationPlayState = \"running\", this;\n    }, Keyframes.prototype.play = function(animationOptions, callbacks) {\n        var _this = this;\n        this.log(\"play\", animationOptions);\n        var _a = callbacks || {}, _b = _a.onBeforeStart, onBeforeStart = void 0 === _b ? null : _b, _c = _a.onStart, onStart = void 0 === _c ? null : _c, _d = _a.onIteration, onIteration = void 0 === _d ? null : _d, _e = _a.onEnd, onEnd = void 0 === _e ? null : _e, _f = _a.onCancel, onCancel = void 0 === _f ? null : _f;\n        if (!0 === this.playing && (this.log(\"cancelled\"), this.previousCancel && (this.queueStore = [], \n        this.previousCancel())), onCancel && (this.previousCancel = onCancel), this.mountedElement.style.animationName === this.getAnimationName(animationOptions)) return this.freeze(), \n        requestAnimationFrame(function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [ 4, this.reset() ];\n\n                      case 1:\n                        return _a.sent(), this.play(animationOptions, callbacks), this.unfreeze(), [ 2 ];\n                    }\n                });\n            });\n        }), this;\n        this.playing = !0;\n        function addEvent(type, eventCallback) {\n            var listenerName = type + \"Listener\";\n            _this.mountedElement.removeEventListener(type, _this[listenerName]), _this[listenerName] = eventCallback, \n            _this.mountedElement.addEventListener(type, _this[listenerName]);\n        }\n        var animationCount = Array.isArray(animationOptions) ? animationOptions.length : 1, animationcss = Keyframes.playCSS(animationOptions);\n        return this.log(\"onBeforeStart\"), onBeforeStart && onBeforeStart(), this.mountedElement.style.animationPlayState = \"running\", \n        this.mountedElement.style.animation = animationcss, addEvent(\"animationiteration\", function(e) {\n            _this.log(\"animationiteration\", e), onIteration && onIteration(e);\n        }), addEvent(\"animationend\", function(e) {\n            --animationCount || (_this.log(\"ended\", e), _this.playing = !1, onEnd && !animationCount && onEnd(e));\n        }), addEvent(\"animationstart\", function(e) {\n            _this.log(\"onStart\", e), onStart && onStart(e);\n        }), this;\n    }, Keyframes.prototype.playNext = function() {\n        var _this = this, animationOption = this.queueStore[this.queueStore.length - 1];\n        animationOption ? this.log(\"playNext\", animationOption) : this.log(\"Queue Complete\"), \n        animationOption ? this.play(animationOption, {\n            onEnd: function(e) {\n                _this.queueStore.pop(), _this.callbacks.onEnd && _this.callbacks.onEnd(e), _this.playNext();\n            },\n            onCancel: this.callbacks.onCancel,\n            onIteration: this.callbacks.onIteration\n        }) : this.callbacks.onQueueComplete && this.callbacks.onQueueComplete();\n    }, Keyframes.prototype.removeEvents = function() {\n        return this.log(\"events cleared\"), this.mountedElement.removeEventListener(\"animationiteration\", this.animationiterationListener), \n        this.mountedElement.removeEventListener(\"animationend\", this.animationendListener), \n        this.mountedElement.removeEventListener(\"animationstart\", this.animationstartListener), \n        this;\n    }, Keyframes.prototype.updateCallbacks = function(callbacks) {\n        callbacks && (this.callbacks = __assign(__assign({}, this.callbacks), callbacks));\n    }, Keyframes.prototype.queue = function(animationOptions, callbacks) {\n        var _this = this, currentQueueLength = this.queueStore.length;\n        this.updateCallbacks(__assign(__assign({}, defaultCallbacks), callbacks));\n        var _animationOptions = clone(animationOptions);\n        return Array.isArray(_animationOptions) ? this.queueStore = _animationOptions.reverse().concat(this.queueStore) : this.queueStore.unshift(_animationOptions), \n        this.log(\"queued\", animationOptions, currentQueueLength), currentQueueLength ? this.playing || this.playNext() : requestAnimationFrame(function() {\n            return __awaiter(_this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [ 4, this.reset() ];\n\n                      case 1:\n                        return _a.sent(), this.playNext(), [ 2 ];\n                    }\n                });\n            });\n        }), this;\n    }, Keyframes.prototype.chain = function(animationOptions, callbacks) {\n        return this.queue(animationOptions, callbacks), this;\n    }, Keyframes.prototype.resetQueue = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                  case 0:\n                    return this.log(\"resetQueue\"), [ 4, wait() ];\n\n                  case 1:\n                    return _a.sent(), this.removeEvents(), this.queueStore = [], [ 4, this.reset() ];\n\n                  case 2:\n                    return _a.sent(), [ 2, this ];\n                }\n            });\n        });\n    }, Keyframes.prototype.loop = function(animationOptions, callbacks) {\n        return void 0 === callbacks && (callbacks = {}), __awaiter(this, void 0, void 0, function() {\n            var populateQueue, _this = this;\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                  case 0:\n                    return this.log(\"loop\", animationOptions), [ 4, this.resetQueue() ];\n\n                  case 1:\n                    return _a.sent(), (populateQueue = function() {\n                        _this.queue(animationOptions, __assign(__assign({}, callbacks), {\n                            onQueueComplete: function() {\n                                return populateQueue();\n                            }\n                        }));\n                    })(), [ 2, this ];\n                }\n            });\n        });\n    }, Keyframes.prototype.getAnimationName = function(animationObject) {\n        var _this = this;\n        return Array.isArray(animationObject) ? animationObject.map(function(o) {\n            return _this.getAnimationName(o);\n        }).join(\", \") : \"string\" == typeof animationObject ? animationObject.split(\" \")[0] : animationObject.name;\n    }, Keyframes.playCSS = function(animationOptions) {\n        function animObjToStr(obj) {\n            var newObj = __assign({\n                duration: \"0s\",\n                timingFunction: \"ease\",\n                delay: \"0s\",\n                iterationCount: 1,\n                direction: \"normal\",\n                fillMode: \"forwards\"\n            }, obj);\n            return [ newObj.name, newObj.duration, newObj.timingFunction, newObj.delay, newObj.iterationCount, newObj.direction, newObj.fillMode ].join(\" \");\n        }\n        if (Array.isArray(animationOptions)) {\n            for (var animationOptionsStrings = [], i = 0; i < animationOptions.length; i += 1) {\n                var option = animationOptions[i];\n                animationOptionsStrings.push(\"string\" == typeof option ? option : animObjToStr(option));\n            }\n            return animationOptionsStrings.join(\", \");\n        }\n        return \"string\" == typeof animationOptions ? animationOptions : animObjToStr(animationOptions);\n    }, Keyframes.generateCSS = function(frameData) {\n        var css = \"@keyframes \" + frameData.name + \" {\";\n        for (var key in frameData) {\n            if (\"name\" !== key && \"media\" !== key && \"complete\" !== key) css += key + \" {\" + objToCss(frameData[key]) + \"}\";\n        }\n        return css += \"}\", frameData.media && (css = \"@media \" + frameData.media + \"{\" + css + \"}\"), \n        css;\n    }, Keyframes.generate = function(frameData) {\n        this.addToRuleCache(frameData);\n        var css = this.generateCSS(frameData), oldFrameIndex = Keyframes.rules.indexOf(frameData.name);\n        -1 < oldFrameIndex && (Keyframes.sheet.deleteRule(oldFrameIndex), Keyframes.rules.splice(oldFrameIndex, 1));\n        var ruleIndex = (Keyframes.sheet.cssRules || Keyframes.sheet.rules).length;\n        Keyframes.sheet.insertRule(css, ruleIndex), Keyframes.rules[ruleIndex] = frameData.name;\n    }, Keyframes.define = function(frameOptions) {\n        if (Array.isArray(frameOptions)) for (var i = 0; i < frameOptions.length; i += 1) this.generate(frameOptions[i]); else this.generate(frameOptions);\n    }, Keyframes.defineCSS = function(frameOptions) {\n        if (Array.isArray(frameOptions)) {\n            for (var css = \"\", i = 0; i < frameOptions.length; i += 1) css += this.generateCSS(frameOptions[i]);\n            return css;\n        }\n        return this.generateCSS(frameOptions);\n    }, Keyframes.addToRuleCache = function(frameData) {\n        if (!this.ruleCache[frameData.name]) {\n            var rules = Object.values(frameData).filter(function(v) {\n                return \"object\" == typeof v;\n            }).map(function(v) {\n                return Object.keys(v);\n            }).flat();\n            this.ruleCache[frameData.name] = __spread(new Set(rules));\n        }\n    }, Keyframes.prototype.log = function(msg) {\n        for (var detail = [], _i = 1; _i < arguments.length; _i++) detail[_i - 1] = arguments[_i];\n        this.debug;\n    }, Keyframes.sheet = keyframesSheet, Keyframes.rules = [], Keyframes.ruleCache = {}, \n    Keyframes.clearRules = function() {\n        for (Keyframes.rules = []; Keyframes.sheet.cssRules.length; ) Keyframes.sheet.deleteRule(0);\n    }, Keyframes;\n}();\n\nexports.isBrowser && (window.Keyframes = Keyframes), __export(__webpack_require__(/*! ./pathfinder */ \"./node_modules/@keyframes/core/dist/pathfinder.js\")), \n__export(__webpack_require__(/*! ./spritesheet */ \"./node_modules/@keyframes/core/dist/spritesheet.js\")), exports.default = Keyframes;\n\n\n//# sourceURL=webpack:///./node_modules/@keyframes/core/dist/keyframes.js?");

/***/ }),

/***/ "./node_modules/@keyframes/core/dist/pathfinder.js":
/*!*********************************************************!*\
  !*** ./node_modules/@keyframes/core/dist/pathfinder.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keyframes_1 = __webpack_require__(/*! ./keyframes */ \"./node_modules/@keyframes/core/dist/keyframes.js\");\nfunction getCirclePoint(radians, radius, center) {\n    return {\n        x: center.x + radius * Math.cos(radians),\n        y: center.y + radius * Math.sin(radians)\n    };\n}\nvar coord = function (x, y) {\n    if (x === void 0) { x = 0; }\n    if (y === void 0) { y = 0; }\n    return { x: x, y: y };\n};\nvar B1 = function (t) { return t * t * t; };\nvar B2 = function (t) { return 3 * t * t * (1 - t); };\nvar B3 = function (t) { return 3 * t * (1 - t) * (1 - t); };\nvar B4 = function (t) { return (1 - t) * (1 - t) * (1 - t); };\nvar getBezier = function (percent, C1, C2, C3, C4) {\n    var pos = coord();\n    pos.x =\n        C1.x * B1(percent) +\n            C2.x * B2(percent) +\n            C3.x * B3(percent) +\n            C4.x * B4(percent);\n    pos.y =\n        C1.y * B1(percent) +\n            C2.y * B2(percent) +\n            C3.y * B3(percent) +\n            C4.y * B4(percent);\n    return pos;\n};\nexports.bezierPath = function (keyframeOptions, p1, p2, p3, p4) {\n    var opts = __assign({ bezierSteps: 100, transform: \"\" }, keyframeOptions);\n    if (p4 == null) {\n        p4 = p1;\n    }\n    var vector1 = coord(p1[0], p1[1]);\n    var vector2 = coord(p2[0], p2[1]);\n    var vector3 = coord(p3[0], p3[1]);\n    var vector4 = coord(p4[0], p4[1]);\n    var points = {};\n    var step = 1 / opts.bezierSteps;\n    for (var i = 0; i <= 1.01; i += step) {\n        var newPosition = getBezier(i, vector1, vector4, vector3, vector2);\n        points[100 - Math.round(i * 100) + \"%\"] = {\n            transform: \"translate(\" + newPosition.x + \"px,\" + newPosition.y + \"px) \" + opts.transform\n        };\n    }\n    return Object.assign({}, keyframeOptions, points);\n};\nexports.circlePath = function (keyframeOptions, center, radius) {\n    var opts = __assign({ circleSteps: 100, transform: \"\" }, keyframeOptions);\n    var points = {};\n    var newCenter = coord(center[0], center[1]);\n    var pieandahalf = 1.5 * Math.PI;\n    var notmuchpie = Math.PI / 180;\n    var stepPercentage = 100 / opts.circleSteps;\n    var stepDegree = 360 / opts.circleSteps;\n    for (var i = 0; i <= opts.circleSteps; i += 1) {\n        var degree = stepDegree * i;\n        var radians = pieandahalf + degree * notmuchpie;\n        var newpos = getCirclePoint(radians, radius, newCenter);\n        points[Math.round(stepPercentage * i) + \"%\"] = {\n            transform: \"translate(\" + newpos.x + \"px,\" + newpos.y + \"px) \" + opts.transform\n        };\n    }\n    for (var step in keyframeOptions) {\n        var rules = keyframeOptions[step];\n        for (var newstep in points) {\n            var newrules = points[newstep];\n            if (step === newstep) {\n                if (newrules.transform && rules.transform) {\n                    points[newstep].transform = newrules.transform + \" \" + rules.transform;\n                    break;\n                }\n            }\n        }\n    }\n    return Object.assign({}, keyframeOptions, points);\n};\nif (keyframes_1.isBrowser) {\n    var _window = window;\n    if (_window.Keyframes) {\n        _window.Keyframes.bezierPath = exports.bezierPath;\n        _window.Keyframes.circlePath = exports.circlePath;\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@keyframes/core/dist/pathfinder.js?");

/***/ }),

/***/ "./node_modules/@keyframes/core/dist/spritesheet.js":
/*!**********************************************************!*\
  !*** ./node_modules/@keyframes/core/dist/spritesheet.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keyframes_1 = __webpack_require__(/*! ./keyframes */ \"./node_modules/@keyframes/core/dist/keyframes.js\");\nexports.spriteSheet = function (_a) {\n    var _b = _a.rows, rows = _b === void 0 ? 1 : _b, _c = _a.cols, cols = _c === void 0 ? 1 : _c, _d = _a.width, width = _d === void 0 ? 0 : _d, _e = _a.height, height = _e === void 0 ? 0 : _e, rest = __rest(_a, [\"rows\", \"cols\", \"width\", \"height\"]);\n    var defaults = {\n        offsetX: 0,\n        offsetY: 0,\n        count: rows * cols,\n        spriteWidth: width / cols,\n        spriteHeight: height / rows,\n        loop: true,\n    };\n    var opts = __assign(__assign(__assign({}, defaults), { rows: rows, cols: cols, width: width, height: height }), rest);\n    var spriteStep = 100 / opts.count;\n    var spriteFrames = {};\n    var x = opts.offsetX;\n    var y = opts.offsetY;\n    for (var i = 0; i < opts.count; i += 1) {\n        spriteFrames[Math.round(spriteStep * i) + \"%\"] = {\n            backgroundPosition: \"-\" + x + \"px -\" + y + \"px\",\n        };\n        if (x >= opts.width - opts.spriteWidth) {\n            y += opts.spriteHeight;\n        }\n        else {\n            x += opts.spriteWidth;\n        }\n    }\n    return Object.assign({}, { name: opts.name }, spriteFrames);\n};\nexports.playSpriteSheet = function (name, time, loops) {\n    if (loops === void 0) { loops = 'infinite'; }\n    if (loops && loops < 0) {\n        loops = 'infinite';\n    }\n    return name + \" \" + time + \" steps(1) \" + loops;\n};\nif (keyframes_1.isBrowser) {\n    var _window = window;\n    if (_window.Keyframes) {\n        _window.Keyframes.spriteSheet = exports.spriteSheet;\n        _window.Keyframes.playSpriteSheet = exports.playSpriteSheet;\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@keyframes/core/dist/spritesheet.js?");

/***/ }),

/***/ "./node_modules/add-px-to-style/index.js":
/*!***********************************************!*\
  !*** ./node_modules/add-px-to-style/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* The following list is defined in React's core */\nvar IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\nmodule.exports = function(name, value) {\n  if(typeof value === 'number' && !IS_UNITLESS[ name ]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/add-px-to-style/index.js?");

/***/ }),

/***/ "./node_modules/hyphenate-style-name/index.js":
/*!****************************************************!*\
  !*** ./node_modules/hyphenate-style-name/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (cache.hasOwnProperty(name)) {\n    return cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (hyphenateStyleName);\n\n\n//# sourceURL=webpack:///./node_modules/hyphenate-style-name/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _core = __webpack_require__(/*! @keyframes/core */ \"./node_modules/@keyframes/core/dist/keyframes.js\");\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Import keyframes module\n\nvar techniques_list = document.querySelector(\".techniques\"); // Techniques list container\nvar techniques = document.querySelectorAll(\".techniques__technique\"); // List of techniques\n\nvar breathe_container = document.querySelector(\".breathe\"); // Container for technique details and practice actions\nvar technique_details = document.querySelector(\".technique\"); // Each technique details\n\nvar exit_btn = document.querySelector(\".close\"); // Close technique pop up button\nvar back_btn = document.querySelector(\".back\"); // Navigate technique pop up (Go back)\n\nvar practice_visual = document.querySelector(\".practice__visual span\"); // Practice technique circle visual\nvar practice_task = document.querySelector(\".practice__task\"); // Practice technique task visual\n\n// List of techniques data\nvar list = [{\n\tid: 1,\n\tname: \"Box Breathing\",\n\tdesc: \"This technique (a.k.a Square Breathing) is a calming breathing technique used by people like athletes in stressful situations. Breathe in for 4 seconds, followed by holding in breath for 4 seconds, then exhale for 4 seconds, followed by holding out breath for 4 seconds.\",\n\tsecs: [4, 4, 4, 4]\n}, {\n\tid: 2,\n\tname: \"4-7-8 Breathing\",\n\tdesc: \"This technique is a form of deep breathing that helps relieve stress and fall asleep faster. Breathe in for 4 seconds, hold breath for 7 seconds and, then exhale for 8 seconds.\",\n\tsecs: [4, 7, 8, 0]\n}, {\n\tid: 3,\n\tname: \"Deep Breathing\",\n\tdesc: \"Used to reduce anxiety, this technique involves inhaling and holding for a few seconds and exhaling for a longer period. Breathe in for 4 seconds, hold in breath for 4 seconds and, then exhale for 6 seconds.\",\n\tsecs: [4, 4, 6, 0]\n}, {\n\tid: 4,\n\tname: \"Equal Breathing\",\n\tdesc: \"This mindful technique involves inhaling for the same amount of time as exhaling. Breathe in for 4 seconds and breathe out for 4 seconds.\",\n\tsecs: [4, 0, 4, 0]\n}, {\n\tid: 5,\n\tname: \"Breath Counting\",\n\tdesc: \"This technique is exactly what it sounds like and it helps become more mindful. Breathe as you would normally do and count each inhale and each exhale.\",\n\tsecs: [2, 0, 2, 0]\n}, {\n\tid: 6,\n\tname: \"Rhythmic Breathing\",\n\tdesc: \"As its name suggests, this technique follows a rhythm. Breathe in for 6 seconds, hold in breath for 3 seconds, Breathe out for 6 seconds and hold out breath for 3 seconds.\",\n\tsecs: [6, 3, 6, 3]\n}];\n\nvar t_o = []; // Timeout variable for reference\nvar stop_practice = false; // End practice boolean\nvar current_technique = void 0; // Currently selected technique\nvar animate = void 0; // Keyframes (Animation) instance\n\nvar expanded = { transform: \"scale(.95)\" };\nvar collapsed = { transform: \"scale(.65)\" };\n\n// Render list of techniques to the UI\nvar render_techniques_list = function render_techniques_list(array_list) {\n\tvar technique = void 0;\n\n\ttechniques_list.innerHTML = \"\";\n\tarray_list.forEach(function (item) {\n\t\ttechnique = document.createElement(\"div\");\n\t\ttechnique.innerHTML = \"\\n\\t\\t\\t<p>\" + item.name + \"</p>\\n\\t\\t\\t<span>Click to view</span>\\n\\t\\t\";\n\t\ttechnique.classList.add(\"techniques__technique\");\n\t\ttechnique.setAttribute(\"data-id\", \"\" + item.id);\n\t\ttechnique.addEventListener(\"click\", function () {\n\t\t\tdisplay_details(item);\n\t\t});\n\n\t\t// Render markup to UI\n\t\ttechniques_list.appendChild(technique);\n\t});\n};\nrender_techniques_list(list);\n\n// Clear all timeout\nvar reset_timeouts = function reset_timeouts() {\n\tfor (var i = 0; i < t_o.length; i++) {\n\t\tclearTimeout(t_o[i]);\n\t}\n\tt_o = [];\n};\n\n// Resets all functions and visuals\nvar reset_practice = function reset_practice() {\n\tvar scale_value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.63;\n\n\tif (animate) animate.reset();\n\treset_timeouts();\n\tpractice_visual.style.transform = \"scale(\" + scale_value + \")\";\n};\n\n// Inialize keyframes module instance\nvar init_keyframes = function init_keyframes() {\n\t_core2.default.define([{\n\t\tname: \"breathe-in\",\n\t\tfrom: collapsed,\n\t\tto: expanded\n\t}, {\n\t\tname: \"breathe-out\",\n\t\tfrom: expanded,\n\t\tto: collapsed\n\t}, {\n\t\tname: \"hold-in\",\n\t\tfrom: expanded,\n\t\tto: expanded\n\t}, {\n\t\tname: \"hold-out\",\n\t\tfrom: collapsed,\n\t\tto: collapsed\n\t}]);\n\n\tanimate = new _core2.default(practice_visual);\n};\n\n// Update task for each round: breathe in, out or hold in, out\nvar update_task = function update_task(message) {\n\tpractice_task.innerHTML = message;\n};\n\n// Countdown timer function for get_ready()\nvar interval = void 0;\nvar countdown_timer = function countdown_timer(seconds) {\n\tclearInterval(interval);\n\tvar now = Date.now();\n\tvar later = now + seconds * 1000;\n\tupdate_task(\"Ready...\\uD83D\\uDE03\");\n\n\tinterval = setInterval(function () {\n\t\tvar timeLeft = Math.round((later - Date.now()) / 1000);\n\n\t\tif (timeLeft <= 0) {\n\t\t\tclearInterval(interval);\n\t\t\treturn;\n\t\t}\n\t\tupdate_task(\"Ready...\\uD83D\\uDE03 <br> \" + timeLeft);\n\t}, 1000);\n};\n\n// Wait til user is ready (3 seconds) and run breathe\nvar get_ready = function get_ready(seconds, rounds) {\n\t// update_task(\"Ready...ðŸ˜ƒ\");\n\tcountdown_timer(4);\n\trun_after(4, function () {\n\t\treturn breathe(seconds, rounds);\n\t});\n};\n\n// Determine number of rounds for a two minute (120s/2min) session\nvar determine_rounds = function determine_rounds(seconds_arr) {\n\tvar total_seconds = seconds_arr.reduce(function (sum, breath) {\n\t\treturn sum + breath;\n\t});\n\tconsole.log(Math.ceil(120 / total_seconds));\n\treturn Math.ceil(120 / total_seconds);\n};\n\n// Generate random images for description mode\nvar get_random_image = function get_random_image() {\n\tvar random_num = Math.ceil(Math.random() * 4);\n\treturn \"./img/random/\" + random_num + \".svg\";\n};\n\n// Close pop-up and return to main page\nexit_btn.addEventListener(\"click\", function () {\n\t// Reset and stop practice mode\n\treset_practice();\n\tstop_practice = true;\n\n\tif (breathe_container.classList.contains(\"description-mode\")) {\n\t\tbreathe_container.classList.remove(\"description-mode\");\n\t} else if (breathe_container.classList.contains(\"practice-mode\")) {\n\t\tbreathe_container.classList.remove(\"practice-mode\");\n\t}\n});\n\n// Navigate pop-up\nback_btn.addEventListener(\"click\", function () {\n\t// Reset and stop practice mode\n\treset_practice();\n\tstop_practice = true;\n\n\tif (breathe_container.classList.contains(\"practice-mode\")) {\n\t\tbreathe_container.classList.add(\"description-mode\");\n\t\tbreathe_container.classList.remove(\"practice-mode\");\n\t}\n});\n\n// Open details for selected technique\nvar display_details = function display_details(item) {\n\tcurrent_technique = item.secs; // Get the seconds for selected technique\n\tvar markup = \"\";\n\tmarkup = \"\\n\\t\\t<div class=\\\"technique__image\\\">\\n\\t\\t\\t<img src=\\\"\" + get_random_image() + \"\\\" alt=\\\"Random Image\\\">\\n\\t\\t</div>\\n\\t\\t<h3 class=\\\"technique__name\\\">\" + item.name + \"</h3>\\n\\t\\t<div class=\\\"technique__description\\\">\\n\\t\\t\\t\" + item.desc + \" \\n\\t\\t\\t<br><br>\\n\\t\\t\\t<span>\\n\\t\\t\\t\\tGet comfortable & Start breathing.\\n\\t\\t\\t</span>\\n\\t\\t</div>\\n\\t\";\n\n\t// Add practice button and attach event listener on it\n\tvar btn = document.createElement(\"div\");\n\tbtn.innerHTML = \"Start\";\n\tbtn.classList.add(\"technique__continue\");\n\tbtn.addEventListener(\"click\", start_practice);\n\n\t// Render markup and button html to UI\n\ttechnique_details.innerHTML = \"\";\n\ttechnique_details.insertAdjacentHTML(\"afterbegin\", markup);\n\ttechnique_details.appendChild(btn);\n\n\tbreathe_container.classList.add(\"description-mode\");\n};\n\n// Switch to practice mode and start practice\nvar start_practice = function start_practice() {\n\tbreathe_container.classList.remove(\"description-mode\");\n\tbreathe_container.classList.add(\"practice-mode\");\n\n\tstop_practice = false;\n\tinit_keyframes();\n\tget_ready(current_technique, determine_rounds(current_technique));\n};\n\nvar run_after = function run_after(s, f) {\n\tif (!stop_practice) {\n\t\tt_o.push(setTimeout(function () {\n\t\t\treturn f();\n\t\t}, s * 1000));\n\t} else {\n\t\treturn;\n\t}\n};\n\n// Hold current breath: in or out\nvar hold = function hold(type, time) {\n\tif (!stop_practice) {\n\t\t// Exit if there's no hold time\n\t\tif (time === 0) return;\n\n\t\tif (type === \"in\") {\n\t\t\tanimate.play({\n\t\t\t\tname: \"hold-in\",\n\t\t\t\tduration: time + \"s\",\n\t\t\t\ttimingFunction: \"linear\",\n\t\t\t\tdelay: \"0s\",\n\t\t\t\titerationCount: 1\n\t\t\t}, {\n\t\t\t\tonBeforeStart: function onBeforeStart() {\n\t\t\t\t\tupdate_task(\"Hold breath...\");\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (type === \"out\") {\n\t\t\tanimate.play({\n\t\t\t\tname: \"hold-out\",\n\t\t\t\tduration: time + \"s\",\n\t\t\t\ttimingFunction: \"linear\",\n\t\t\t\tdelay: \"0s\",\n\t\t\t\titerationCoun: 1\n\t\t\t}, {\n\t\t\t\tonBeforeStart: function onBeforeStart() {\n\t\t\t\t\tupdate_task(\"Hold breath...\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n};\n\n// Expand circle to simulate breathing in\nvar expand = function expand(seconds) {\n\tif (!stop_practice) {\n\t\tvar breathe_in = seconds[0];\n\t\tvar hold_in = seconds[1];\n\n\t\tanimate.play({\n\t\t\tname: \"breathe-in\",\n\t\t\tduration: breathe_in + \"s\",\n\t\t\ttimingFunction: \"linear\",\n\t\t\tdelay: \"0s\",\n\t\t\titerationCount: 1\n\t\t}, {\n\t\t\tonBeforeStart: function onBeforeStart() {\n\t\t\t\tupdate_task(\"Breathe in...\");\n\t\t\t},\n\t\t\tonEnd: function onEnd() {\n\t\t\t\thold(\"in\", hold_in);\n\t\t\t}\n\t\t});\n\t} else {\n\t\treturn;\n\t}\n};\n\n// Collapse circle to simulate breathing out\nvar collapse = function collapse(seconds) {\n\tif (!stop_practice) {\n\t\tvar breathe_out = seconds[2];\n\t\tvar hold_out = seconds[3];\n\n\t\tanimate.play({\n\t\t\tname: \"breathe-out\",\n\t\t\tduration: breathe_out + \"s\",\n\t\t\ttimingFunction: \"linear\",\n\t\t\tdelay: \"0s\",\n\t\t\titerationCount: 1\n\t\t}, {\n\t\t\tonBeforeStart: function onBeforeStart() {\n\t\t\t\tupdate_task(\"Breathe out...\");\n\t\t\t},\n\t\t\tonEnd: function onEnd() {\n\t\t\t\thold(\"out\", hold_out);\n\t\t\t}\n\t\t});\n\t} else {\n\t\treturn;\n\t}\n};\n\n// Run multiple iterations or rounds of breathing\nvar breathe = function breathe(seconds, rounds) {\n\treset_timeouts();\n\n\t// Exit case after 'rounds' of practice\n\tif (!stop_practice) {\n\t\tif (rounds === 0) {\n\t\t\tupdate_task(\"Complete ðŸ˜Š\");\n\t\t\treset_practice(0.65);\n\t\t\trun_after(3, function () {\n\t\t\t\tbreathe_container.classList.remove(\"practice-mode\");\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tvar total_in = seconds[0] + seconds[1]; // Total in-breath time (breathe_in + hold_in)\n\t\tvar total = seconds.reduce(function (s, b) {\n\t\t\treturn s + b;\n\t\t}); // Total breath time: all in and out\n\n\t\t// Run one round of breathing\n\t\trun_after(total_in, function () {\n\t\t\treturn collapse(seconds);\n\t\t});\n\t\texpand(seconds);\n\n\t\t// After one round of breathing, repeat\n\t\trounds -= 1;\n\t\trun_after(total, function () {\n\t\t\treturn breathe(seconds, rounds);\n\t\t});\n\t} else {\n\t\treturn;\n\t}\n};\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });